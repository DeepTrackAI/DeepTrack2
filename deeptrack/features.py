import os
import re
import copy

from abc import ABC, abstractmethod
import numpy as np

from deeptrack.image import Image
from deeptrack.properties import Property, PropertyDict
from deeptrack.utils import get_property


MERGE_STRATEGY_OVERRIDE = 0
MERGE_STRATEGY_APPEND = 1


class Feature(ABC):
    ''' Base feature class.
    Features define a image generation process. Each feature takes an
    input image and alters it using the .get() method. Features can be
    added together using the + operator. In that case the left side of
    the + operator will be used as the input for the Feature on the
    right.

    Whenever a Feature is initiated, all keyword arguments passed to the
    constructor will be wrapped as a Distribution, and stored to the
    `properties` field. When a Feature is resolved, a copy of this
    field is sent as input to the get method, with each value replaced
    by the current_value field of the distribution.


    A typical lifecycle of a feature F is

    F.clear()
        Clears the internal cache of the feature.
    F.update()
        Recursively updates the feature and its parent(s).
    F.resolve()
        Resolves the image generated by the feature.

    Properties
    ----------
    properties : dict
        A dict that contains all keyword arguments passed to the
        constructor wrapped a Distributions. A sampled copy of this
        dict is sent as input to the get function, and is appended
        to the properties field of the output image.
    cache: Image
        Stores the output of a `resolve` call. If this is not
        None, it will be returned instead of calling the get method.
    probability: number
        The probability of calling the get function of this feature
        during a `resolve()` call
    parent: Feature | ndarray
        During a `resolve()` call, this will serve as the input
        to the `get()` method.

    Class Properties
    ----------------
    __name__
        Default name of the Feature.

    Methods
    -------
    update()
        If self is not in history, it calls the update method
        on the `properties` and `parent` and appends itself to
        the history list.
    resolve(image : ndarray, **kwargs)
        Uses the current_value of the properties field to
        generate an image using the .get() method. If the feature has
        a parent, the output of the resolve() call on the parent is
        used as the input to the .get() method, otherwise an Image of
        all zeros is used.
    '''

    __property_verbosity__ = 1
    __list_merge_strategy__ = MERGE_STRATEGY_OVERRIDE
    __distributed__ = True


    def __init__(self, *args, **kwargs):
        '''Constructor
        All keyword arguments passed to the base Feature class will be
        wrapped as a Distribution, as such randomized during a update
        step.
        '''
        
        properties = getattr(self, "properties", {})
        properties["hash_key"] = Property([lambda: np.random.randint(2 ** 31) for _ in range(4)])

        all_dicts = (kwargs, ) + args

        for property_dict in all_dicts:
            for key, value in property_dict.items():
                properties[key] = Property(value)

        self.properties = PropertyDict(**properties)


        
    @abstractmethod
    def get(self, image, **kwargs):
        ''' Alters an image
        '''


        
    def resolve(
            self,
            image_list=None,
            **global_kwargs):

        # Ensure that image is a list
        image_list = self._format_input(image_list, **global_kwargs)


        # Get the input arguments to the method .get()
        feature_input = self.properties.current_value_dict(is_resolving=True, **global_kwargs)
        
        # Add and update any global keyword arguments
        feature_input.update(global_kwargs)
        
        # Call the _process_properties hook, default does nothing.
        feature_input = self._process_properties(feature_input)

        new_list = self._process_and_get(image_list, **feature_input)
 
        # Add current_properties to the image the class attribute __property_verbosity__
        # is not larger than the passed property_verbosity keyword
        property_verbosity = global_kwargs.get("property_verbosity", 1)
        feature_input["name"] = type(self).__name__
        if self.__property_verbosity__ <= property_verbosity:
            for image in new_list:
                    image.append(feature_input)

        # Merge input and new_list
        if self.__list_merge_strategy__ == MERGE_STRATEGY_OVERRIDE:
            image_list = new_list
        elif self.__list_merge_strategy__ == MERGE_STRATEGY_APPEND:
            image_list = image_list + new_list

        self.has_updated_since_last_resolve = False

        if len(image_list) == 1:
            return image_list[0]
        else:
            return image_list



    def update(self, **kwargs):
        '''
        Updates the state of all properties.
        '''
        self.properties.update(**kwargs)
        return self


    def _process_and_get(self, image_list, **feature_input):

        if self.__distributed__:
            return [Image(self.get(image, **feature_input)) for image in image_list]
        else:
            new_list = self.get(image_list, **feature_input)

            if not isinstance(new_list, list):
                new_list = [Image(new_list)]
            
            return new_list



    def plot(self, input_image=None, interval=None, **kwargs):
        ''' Resolves the image and shows the result

        Parameters
        ----------
        shape
            shape of the image to be drawn
        input_image
            
        kwargs
            keyword arguments passed to the method plt.imshow()
        '''
        
        import matplotlib.pyplot as plt
        import matplotlib.animation as animation
        from IPython.display import HTML, display

        if input_image is not None:
            input_image = [Image(input_image)]

        output_image = self.resolve(input_image)

        # If a list, assume video
        if isinstance(output_image, Image):
            # Single image
            plt.imshow(output_image[:, :, 0], **kwargs)
            plt.show()

        else:
            # Assume video
            fig = plt.figure()
            images = []
            for image in output_image:
                images.append([plt.imshow(image[:, :, 0], **kwargs)])

            interval = (interval
                        or get_property(output_image[0], "interval") 
                        or (1 / 30 * 1000))


            anim = animation.ArtistAnimation(fig, images, interval=interval, blit=True,
                                    repeat_delay=0)

            try: 
                get_ipython # Throws NameError if not in Notebook
                display(HTML(anim.to_jshtml()))

            except NameError as e:
                # Not in an notebook
                plt.show()

            except RuntimeError as e:
                # In notebook, but animation failed
                import ipywidgets as widgets
                Warning("Javascript animation failed. This is a non-performant fallback.")
                def plotter(frame=0):
                    plt.imshow(output_image[frame][:, :, 0], **kwargs)
                    plt.show()

                return widgets.interact(plotter, frame=widgets.IntSlider(value=0, min=0, max=len(images)-1, step=1))


        
    def _format_input(self, image_list, **kwargs):
        
        if image_list is None:
            if self.__distributed__:
                return [None]
            else:
                return []
        elif not isinstance(image_list, list):
            return [image_list]
        else:
            return image_list
            

    def _process_properties(self, propertydict):
        '''Preprocess the input to the method .get()

        Optional hook for subclasses to preprocess data before calling
        the method .get()

        '''
        return propertydict


    def sample(self, **kwargs):
        return self


    def __add__(self, other):
        return Branch(self, other)

    def __radd__(self, other):
        if not other:
            return self
        else:
            return NotImplemented


    def __mul__(self, other):
        return Probability(self, other)

    __rmul__ = __mul__


    def __pow__(self, other):
        return Duplicate(self, other)


    def __call__(self, other):
        return Wrap(other, self)



class StructuralFeature(Feature):
    __property_verbosity__ = 2
    __distributed__ = False


class Branch(StructuralFeature):

    def __init__(self, F1, F2, *args, **kwargs):
        super().__init__(*args, feature_1=F1, feature_2=F2, **kwargs)


    def get(self, image, feature_1=None, feature_2=None, **kwargs):
        image = feature_1.resolve(image, **kwargs)
        image = feature_2.resolve(image, **kwargs)
        return image



class Probability(StructuralFeature):


    def __init__(self, feature, probability, *args, **kwargs):
        super().__init__(
            *args,
            feature=feature,
            probability=probability,
            random_number=np.random.rand,
            **kwargs)


    def get(self, image,
            feature=None, 
            probability=None, 
            random_number=None,
            **kwargs):

        if random_number < probability:
            image = feature.resolve(image, **kwargs)

        return image


class Duplicate(StructuralFeature):

    def __init__(self, feature, num_duplicates, *args, **kwargs):

        self.feature = feature
        super().__init__(
            *args,
            num_duplicates=num_duplicates, #py > 3.6 dicts are ordered by insert time.
            features=lambda: [copy.deepcopy(feature) for _ in range(self.properties["num_duplicates"].current_value)],
            **kwargs)

    def get(self, image, features=None, **kwargs):

        for feature in features:
            image = feature.resolve(image, **kwargs)
        return image


    def update(self, **kwargs):
        super().update(**kwargs)

        for feature in self.properties["features"].current_value:
            feature.update(**kwargs)


class Wrap(StructuralFeature):

    def __init__(self, feature_1, feature_2, *args, **kwargs): 
        super().__init__(feature_1=feature_1, feature_2=feature_2)

    def get(self, image, *args, feature_1=None, feature_2=None, **kwargs):
        image = feature_1.resolve(image, **feature_2.properties.current_value_dict(), **kwargs)
        image = feature_2.resolve(image, **kwargs)
        return image


class Load(Feature):


    def __init__(self,
                 path):
        self.path = path

        # Initiates the iterator
        super().__init__(loaded_image=next(self))


    def get(self, image, loaded_image=None, **kwargs):
        return image + loaded_image


    def __next__(self):
        while True:
            file = np.random.choice(self.get_files())
            image = np.load(file)
            np.random.shuffle(image)
            for i in range(len(image)):
                yield image[i]



    def get_files(self):

        if os.path.isdir(self.path):
            return [os.path.join(self.path, file)
                    for file in os.listdir(self.path) 
                    if os.path.isfile(os.path.join(self.path, file))]

        dirname = os.path.dirname(self.path)
        files = os.listdir(dirname)
        pattern = os.path.basename(self.path)
        return [os.path.join(self.path, file)
                for file in files
                if os.path.isfile(os.path.join(self.path, file))
                and re.match(pattern, file)]